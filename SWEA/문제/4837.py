import sys
sys.stdin = open("input4837.txt")
# 테스트케이스를 입력받는다.
T = int(input())
# 모든 부분집합 리스트를 초기화한다.
lst = []
# 집합A를 선언한다.
num = [1,2,3,4,5,6,7,8,9,10,11,12]

# 모든 부분집합 리스트를 구한다.
# 모든 부분집합의 개수는 2^12 개 이다.
# 1<<len(num) : num의 길이가 12이므로 왼쪽으로 한칸씩 12번 비트이동 하게되면 2진수 100000000000 == 2의 12승 이 된다.
# 1<<len(num)의 과정 : 왼쪽으로 한칸씩 비트이동 하므로 000000000001,000000000010,000000000100, ~ , 100000000000
# 즉, for i in range(2**12)이다. : 0부터 ((2의 12승)-1)까지
for i in range(1<<len(num)):
    # 부분집합을 저장할 리스트를 초기화한다.
    sub_lst = []
    # 리스트의 길이만큼 반복한다.
    for j in range(len(num)):
        # 1<<j : 000000000001, 000000000010, 000000000100, ~ , 100000000000 까지 한칸씩 왼쪽으로 가며 반복문을 돌린다.
        # 만약 (i와) (0000000001을 j칸만큼 왼쪽으로 비트이동시킨것)과 &연산을 했을 시 True값이 나온다면
        if i & (1<<j):
            # 부분집합리스트에 num의 j번째 인덱스에 있는 원소를 추가한다.
            sub_lst.append(num[j])
    # 1<<j 반복문이 끝나고 난 후 모든 부분집합 리스트에 현재 부분집합 리스트를 추가한다.
    lst.append(sub_lst)

# 길이가 N인 부분집합만 걸러낸다
for t in range(1, T+1):
    # 부분집합의 원소의 수와 부분집합의 합의 입력값을 받는다.
    # N : 부분집합의 원소의 수
    # K : 부분집합의 합
    N, K = map(int, input().split())
    # 길이가 N인 리스트만 담겨있는 리스트 len_lst를 초기화 한다.
    len_lst = []
    # lst의 0번째 인덱스에 들어있는 리스트부터 ((2의 12승)-1)에 들어있는 리스트까지 검사하면서
    for k in lst:
        # lst내의 i번째 리스트의 길이가 N과 같다면
        if len(k)==N:
            # 해당 리스트를 len_lst에 추가한다.
            len_lst.append(k)
    
    # 합 일치 여부 확인
    # 카운트 값 초기화
    cnt = 0
    # 길이가 N인 리스트만 담겨있는 리스트를 검사하면서
    for u in len_lst:
        # 리스트 내의 요소의 총 합 초기화
        res = 0
        # 해당 리스트 내의 요소들의 합 구하기
        # 0~N-1까지 반복하면서 (u는 len_lst에 담겨있는 리스트이고 len_lst에 담겨있는 모든 리스트의 길이가 N 이기 때문)
        for l in range(len(u)):
            # len_lst의 i번째 인덱스를 결과값에 더해준다
            res += u[l]
        # 반복문이 끝나고 난 후 만약 결과값이 K와 같다면
        if res == K:
            # 카운트 횟수를 1회 올린다.
            cnt += 1
    # 테스트 케이스의 회차와 최종 카운트 값을 출력한다.
    # 테스트 케이스의 회차 : t
    # 최종 카운트 값 : cnt
    print("#{} {}".format(t, cnt))
